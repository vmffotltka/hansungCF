#### 1. 개관 및 도입

알고리즘은 무엇일까요? 상황을 가정해봅시다. 1부터 100까지 전부 더하는 작업을 하고 싶습니다. 어떻게 할 수 있을까요?

    1. sum = 0 이라는 변수를 선언하고, 반복문을 1부터 100까지 돌려 전부 더하는 방법
    2. 시그마 공식을 이용하여, (100 + 101) / 2를 구하는 방법

이처럼, *주어진 문제를 해결하는 방법을 명료하게 써 놓은 것*을 **알고리즘**이라고 합니다. 주관적이거나 모호한 것은 알고리즘이라고 할 수 없습니다.
***

#### 2. 알고리즘 시간 측정하기

좀 더 빠른 알고리즘을 고안하기 위해 우리는 알고리즘의 **속도**를 어떻게 측정할 지를 알아야 합니다.
###### ex1)
```c
int sum = 0;
for (int i = 1; i <= 100; i++) {
    sum += i;
}
printf("%d", sum);
```
```c
printf("%d", (100 + 101) / 2);
```
위의 예를 보면, 첫 번째 방법은 반복문을 100번 돌려야 하기 때문에 두 번째 방법에 비해 시간이 더 오래 걸릴 것입니다.


한 가지 예를 더 들어봅시다. 100명의 사람 중에서 순서 상관없이 2명을 뽑는 경우의 수를 구하는 방법은 무엇일까요?
###### ex2)
```c
int count = 0;
for (int i = 1; i <= 100; i++) {
    for (int j = i + 1; j <= 100; j++) {
        count++;
    }
}
printf("%d", count); # 전부 구하기
```
```c
printf("%d", 100 * 99 / 2); # nCr 공식 활용
```
첫 번째 방법은 반복문이 100 * 99 / 2 번 돌아가게 되어 두 번째 방법에 비해 시간이 더 오래 걸릴 것입니다.

이처럼, 알고리즘의 수행 시간을 지배하는 것은 **반복문**입니다. 반복문이 수행되는 횟수는 알고리즘의 수행 시간과 직결됩니다.
***

#### 3. 시간 복잡도

**시간 복잡도**(time complexity)란 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것입니다.

    ex1 의 경우 : N
    ex2 의 경우 : N(N - 1) / 2
    
위의 두 예제 모두 **입력의 크기**가 수행 시간을 결정하고 있습니다.

그러나 입력의 크기가 수행 시간을 결정하는 유일한 척도는 아닙니다. **입력이 어떤 형태로 구성되어 있는지**도 수행 시간에 영향을 미칩니다.
예를 들어, 배열을 선형 탐색하여 원소를 찾는 함수가 있다고 합시다.
```cpp
int firstIndex(const vector<int>& array, int element) {
    for (int i = 0; i < array.size(); i++) {
        if (array[i] == element)
            return i;
    }
    return -1;
}
```
이 함수의 시간 복잡도는 무엇일까요? array의 크기만큼 반복문이 돌아가기 때문에 $N$ 이라고 볼 수 있습니다.
그런데 입력의 형태를 다르게 준다면 어떻게 될까요?

    최선의 경우 : 찾고자 하는 element가 맨 앞에 있음.
    최악의 경우 : 찾고자 하는 element가 맨 뒤에 있음.
    
최선의 경우는 반복문이 한 번만 돌아가지만, 최악의 경우엔 반복문이 $N$ 번 돌아갑니다.

우리가 코딩테스트에서 접하는 문제들은 최선의 데이터도 있고, 최악의 데이터도 있기 때문에 항상 최악을 염두에 두고 알고리즘을 짜야만 합니다.
***

#### 4. 점근적 시간 표기 : Big-O Notation

시간 복잡도는 계산하기 너무 힘들다는 문제가 있습니다. 위 예제들은 쉬운 편이지만, 실제 코드를 짜다 보면 알고리즘이 복잡해질 때가 많습니다. 알고리즘이 복잡할 때 한 줄 한 줄 세고 있는 것은 비효율적이죠.

따라서 우리는 **가장 깊이 중첩된 반복문** 만을 고려하여, 전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 됩니다.
Big-O Notation은 간단히 말해 주어진 함수에서 **가장 빨리 증가하는 항만을 남긴 채 나머지는 다 버리는** 표기법입니다.

    ex2 의 경우 : N(N - 1) / 2

이 경우는 어떻게 될까요?
여기서 가장 빨리 증가하는 항은 $\frac{1}{2}N^2$ 이고, 최고차항의 계수를 버리면 $N^2$ 가 됩니다.

이를 Big-O Notation으로 $O(N^2)$ 이라 합니다.

몇 개의 예시를 보겠습니다.
* $2^NM = O(2^NM)$ 
* $\frac{1}{64}N^2M + 64NM = O(N^2M)$ 
* $N^2M + NlgM + NM^2 = O(N^2M + NM^2)$ 
* $42 = O(1)$ 

세 번째 예에서는 $N^2M$ 과 $NM^2$ **어느 한 쪽이 빠르게 증가한다고 볼 수 없기 때문**에 둘 다 O표기에 포함되었습니다.
네 번째 예는 입력의 크기와 상관없이 항상 같은 시간이 걸립니다. 이를 1만큼의 시간밖에 걸리지 않는다고 씁니다. 이러한 알고리즘을 **상수 시간 알고리즘**이라고도 부릅니다.

***
#### 5. 시간 복잡도 계산의 의의

하지만 우리가 이를 왜 알아야 하며, 계산은 왜 해야 할까요?

O 표기법은 계산하기 간편하고, 알아보기 쉽습니다. 또한 대략적인 **함수의 상한을 나타낸다**는 데 그 의미가 있습니다. 

이 문제를 예로 들어봅시다.

https://www.acmicpc.net/problem/2750

$N$ 의 범위가 1 ~ 1000이고, 시간 제한은 1초입니다.
언어마다 다르나, 반복문 1억번 돌리는 속도는 약 0.5초입니다.

* $O(N)$ 0.000005s
* $O(N^2)$ 0.005s
* $O(N^3)$ 5s
    
이므로, $O(N^3)$ 의 알고리즘을 짜면 통과할 수 없다는 것을 알 수 있습니다.
따라서, 우리는 $O(N)$ 이나 $O(N^2)$ 으로 알고리즘을 짜면 통과할 수 있겠다는 것을 **예측해볼 수 있습니다.**

한번 더 예를 들어볼까요?

https://www.acmicpc.net/problem/11404

N의 범위가 1 ~ 100 이고, 시간 제한은 1초입니다.

* $O(N)$ 0.0000005s
* $O(N^2)$ 0.00005s
* $O(N^3)$ 0.005s

이므로, $O(N^3)$ 의 알고리즘도 통과가 가능할 것이라는 예측이 가능합니다!!

이처럼 문제를 인식하고 설계하는 과정에서, **예측하는 부분이 굉장히 중요**합니다.

https://www.acmicpc.net/problem/14003

이 문제는 N의 범위가 1 ~ 1000000이고, 시간 제한은 3초입니다.
이러한 예측하는 과정 없이, $O(N^2)$ 의 알고리즘을 열심히 짜고 제출하면 TLE를 받게 될 것입니다.
만약 시간 복잡도를 계산하고 설계했다면 $O(N)$ 이나 $O(NlgN)$ 의 알고리즘을 짜야**AC**를 받을 수 있다는 생각을 했을 것입니다.
그렇다면 그 만큼의 시간 절약이 되고, 실제 코딩테스트나 대회에서는 엄청나게 큰 차이를 일으킬 수 있습니다.
