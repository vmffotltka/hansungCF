#### 1. 도입

***



프로그래밍 대회에서 또는 코딩 테스트에서 사람들은 종종 쉬운 문제를 어렵게 푸는 실수를 합니다.

공부를 열심히 할수록 복잡한 알고리즘을 쓰려고 하는데, 때론 쉽고 간단하며 틀릴 가능성이 낮은 답안을 간과할 수 있습니다.

이런 실수를 피하기 위해 좀 더 간단히, **무식하게 풀 수 없을까요?**

###### 무식하게 푼다(brute-force)
> 컴퓨터의 계산 능력을 이용하여 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법

한 가지 예를 들어봅시다. 

    A, B, C, D, E, F, G, H, I, J 를 줄 세울 때 A와 B가 한 칸 이상 떨어져 있는 모든 경우의 수를 구하라.

이를 어떻게 구할 수 있을까요?

    (전체 경우의 수) - (A와 B가 붙어있는 모든 경우의 수)

이렇게 구하면 될 것 같습니다.


하지만 우리는 컴퓨터를 사용하고 있기 때문에, **좀 더 단순히** 생각할 수 있습니다.

    경우의 수를 하나 하나 다 구한 다음, 각각의 경우가 A와 B가 떨어져 있는지 판별하고 맞으면 +1

이렇게 알고리즘을 짤 수 있습니다.

사람의 경우는 10!$10!$ 가지의 경우의 수를 다 구할 수 없겠지만, **컴퓨터는 매우 빠르게 처리가 가능**합니다. 


이를 **완전탐색(exhaustive search)** 이라고 합니다.
>  가능한 방법을 전부 만들어 보는 알고리즘







***

#### 2. 재귀 호출과 완전 탐색


***



컴퓨터가 수행하는 많은 작업들은 대개 작은 조각들로 나누어 볼 수 있습니다.
* 문자열 같은 경우엔 처음 한 글자를 세기, 그 다음 글자를 세기, 그 다음 글자를 세기...
* 수열 같은 경우엔 처음 한 글자를 읽기, 그 다음 수를 읽기, 그 다음 수를 읽기...

그런데 우리가 들여다보는 범위가 작아지면 작아질수록 각 조각들의 형태가 유사해지는 작업들을 많이 볼 수 있습니다. 위의 예시도 마찬가지입니다.
이 때 주로 사용하는 것이 for, while 같은 반복문이죠. 이 때 좋은 방법이 더 있습니다.
바로 **재귀함수(recursive function)**을 사용하는 것입니다.

위의 예시를 for문으로 구현하려면 어떻게 해야 할까요?
```cpp
for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
        if (i == j) continue; // 앞서 선택된 경우
        for (int k = 0; k < 10; k++) {
            for (k == i || k == j) continue; // 앞서 선택된 경우
            .
            .
            .
```

이런 식으로 10중 for문을 구현해야 할 것입니다. 이는 매우 복잡하고 가독성도 너무 떨어집니다.

그렇다면 재귀함수로는 어떻게 구현할 수 있을까요?
```cpp
vector<char> arr; // 원소를 넣을 배열
bool vis[10]; // 앞서 원소를 골랐는지 확인
int cnt = 0;
void recursive_function(int depth) {
	if (depth == 10) { // 10개 고른 경우
		int index_A, index_B; // A와 B의 인덱스
		for (int i = 0; i < 10; i++) {
			if (arr[i] == 'A') index_A = i;
			else if (arr[i] == 'B') index_B = i;
		}
		if (abs(index_A - index_B) > 1) // A와 B가 떨어져 있는 경우
			cnt++;
		return; // return 하여 함수를 종료
	}
	for (int i = 0; i < 10; i++) {
		if (vis[i]) continue; // 앞서 원소가 선택된 경우
		vis[i] = true; // 원소 선택
		arr.push_back(i + 'A'); // 원소 넣기
		recursive_function(depth + 1); // 함수 호출
		vis[i] = false; // 원소 반환
		arr.pop_back(); // 원소 빼기
	}
}
```

이처럼 구현도 간단해지고 가독성도 챙기면서 코드를 작성할 수 있습니다.

재귀함수는 **완전탐색을 구현할 수 있는 유용한 도구** 중 하나 입니다.


***


#### 3. 시간 복잡도 분석


***




완전 탐색의 시간 복잡도는 어떻게 구할 수 있을까요? 아주 간단합니다. 그냥 다 세어보면 됩니다.

위의 예시는 전체 경우의 수는 10!$10!$ 이기 때문에, 시간 복잡도는 O(10!)$O(10!)$ 이라고 할 수 있겠습니다.

10명이 아닌 N$N$명을 줄 세우는 경우라면 시간 복잡도는 O(N!)$O(N!)$ 이 됩니다.




***


#### 4. 많이 등장하는 완전 탐색 유형


***


**1. 모든 순열 만들기**


위 예시와 같은 경우입니다. 이 경우 N$N$이 10을 넘어가면 {c:#e74c3c}TLE{/c} 를 받을 수 있습니다. 즉, 완전 탐색이 아닌 다른 알고리즘을 생각해야 합니다.

Ref.
* C++ : algorithm 헤더 파일의 **next_permutation()**
* Python : itertools 모듈의 **permutations**




**2. 모든 조합 만들기(combination)**


소위 nCr$nCr$을 구하는 것입니다. 

Ref.
* Python : itertools 모듈의 **combinations**




**3. 2n$2^n$가지 경우의 수 만들기**


 n$n$가지 질문에 대한 답이 예/아니오 라고 하면 모든 경우의 수는 2n$2^n$입니다.



***

#### 5. 마무리하며

***

한 주 동안 문제 푸느라 수고 많으셨습니다. 다른 전공 공부와 PS를 병행하는 것은 쉽지 않다고 생각하는데, 생각보다 많이 풀어주셔서 놀랐습니다.


이번 주 주제인 브루트포스는 코딩테스트나 대회에서도 많이 나오는 유형 중 하나입니다. 만약 어려운 문제를 만났을 때 입력의 크기가 작다면, 브루트포스로 풀 수 있는지 점검해보는 것도 좋은 방법입니다.


이번 주 문제도 파이팅 해서 풀어봅시다!
